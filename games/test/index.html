<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Tracking Test Dice</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .dice-container {
            perspective: 1000px;
            margin: 20px;
        }
        
        .test-dice {
            width: 100px;
            height: 100px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.5s ease;
        }
        
        .face {
            position: absolute;
            width: 100px;
            height: 100px;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            color: white;
            backface-visibility: hidden;
        }
        
        /* Physical cube face positions (fixed) */
        .face-front { background: #ff6b6b; transform: rotateY(0deg) translateZ(50px); }
        .face-back { background: #4ecdc4; transform: rotateY(180deg) translateZ(50px); }
        .face-right { background: #45b7d1; transform: rotateY(-90deg) translateZ(50px); }
        .face-left { background: #f9ca24; transform: rotateY(90deg) translateZ(50px); }
        .face-top { background: #f0932b; transform: rotateX(-90deg) translateZ(50px); }
        .face-bottom { background: #6c5ce7; transform: rotateX(90deg) translateZ(50px); }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            max-width: 500px;
        }
        
        button {
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 12px;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        .info {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .face-mapping {
            margin-top: 20px;
            padding: 15px;
            background: #e8f4f8;
            border-radius: 10px;
            font-family: monospace;
            font-size: 14px;
        }
        
        .target-test {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 10px;
        }
        
        .target-btn {
            background: #28a745;
            margin: 5px;
        }
        
        .target-btn:hover {
            background: #1e7e34;
        }
        
        .sequence-log {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Face Tracking Test Dice</h1>
        <p>Tracks which number is on which face and applies single transforms</p>
        
        <div class="dice-container">
            <div class="test-dice" id="testDice">
                <div class="face face-front" id="frontFace">1</div>
                <div class="face face-back" id="backFace">6</div>
                <div class="face face-right" id="rightFace">2</div>
                <div class="face face-left" id="leftFace">5</div>
                <div class="face face-top" id="topFace">3</div>
                <div class="face face-bottom" id="bottomFace">4</div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="applySingleMove('forward')">Roll Forward (X-90°)</button>
            <button onclick="applySingleMove('backward')">Roll Backward (X+90°)</button>
            <button onclick="applySingleMove('left')">Roll Left (Y-90°)</button>
            <button onclick="applySingleMove('right')">Roll Right (Y+90°)</button>
            
            <button onclick="reset()">RESET</button>
            <button onclick="showTargetFace(1)">Show Face 1</button>
            <button onclick="showTargetFace(2)">Show Face 2</button>
            <button onclick="showTargetFace(3)">Show Face 3</button>
            
            <button onclick="showTargetFace(4)">Show Face 4</button>
            <button onclick="showTargetFace(5)">Show Face 5</button>
            <button onclick="showTargetFace(6)">Show Face 6</button>
            <button onclick="testRandomSequence()">Random Sequence</button>
        </div>
        
        <div class="info">
            <div id="currentDisplay">Current Front Face: 1</div>
            <div id="transformDisplay">Transform: none</div>
        </div>
        
        <div class="face-mapping">
            <h3>Current Face Positions:</h3>
            <div id="faceMapping">
                Front: 1 | Back: 6 | Left: 5 | Right: 2 | Top: 3 | Bottom: 4
            </div>
        </div>
        
        <div class="target-test">
            <h3>Target Face Test</h3>
            <p>Test bringing specific faces to front:</p>
            <div>
                Target: <select id="targetSelect">
                    <option value="1">Face 1</option>
                    <option value="2">Face 2</option>
                    <option value="3">Face 3</option>
                    <option value="4">Face 4</option>
                    <option value="5">Face 5</option>
                    <option value="6">Face 6</option>
                </select>
                <button class="target-btn" onclick="findAndExecuteMove()">Find & Execute Move</button>
            </div>
            <div class="sequence-log" id="moveLog"></div>
        </div>
    </div>

    <script>
        // Face tracking system
        let facePositions = {
            front: 1,
            back: 6,
            left: 5,
            right: 2,
            top: 3,
            bottom: 4
        };
        
        let currentTransform = { x: 0, y: 0 };
        const dice = document.getElementById('testDice');
        
        function updateFaceDisplay() {
            // Update the actual face elements with current numbers
            document.getElementById('frontFace').textContent = facePositions.front;
            document.getElementById('backFace').textContent = facePositions.back;
            document.getElementById('rightFace').textContent = facePositions.right;
            document.getElementById('leftFace').textContent = facePositions.left;
            document.getElementById('topFace').textContent = facePositions.top;
            document.getElementById('bottomFace').textContent = facePositions.bottom;
            
            // Update display
            document.getElementById('currentDisplay').textContent = 
                `Current Front Face: ${facePositions.front}`;
            document.getElementById('transformDisplay').textContent = 
                `Transform: rotateX(${currentTransform.x}°) rotateY(${currentTransform.y}°)`;
            document.getElementById('faceMapping').textContent = 
                `Front: ${facePositions.front} | Back: ${facePositions.back} | Left: ${facePositions.left} | Right: ${facePositions.right} | Top: ${facePositions.top} | Bottom: ${facePositions.bottom}`;
        }
        
        function rotateFacesForward() {
            // Forward roll: front→bottom, top→front, back→top, bottom→back
            // Left and right stay the same
            const temp = facePositions.front;
            facePositions.front = facePositions.top;
            facePositions.top = facePositions.back;
            facePositions.back = facePositions.bottom;
            facePositions.bottom = temp;
        }
        
        function rotateFacesBackward() {
            // Backward roll: reverse of forward
            const temp = facePositions.front;
            facePositions.front = facePositions.bottom;
            facePositions.bottom = facePositions.back;
            facePositions.back = facePositions.top;
            facePositions.top = temp;
        }
        
        function rotateFacesLeft() {
            // Left roll: front→left, right→front, back→right, left→back
            // Top and bottom stay the same
            const temp = facePositions.front;
            facePositions.front = facePositions.right;
            facePositions.right = facePositions.back;
            facePositions.back = facePositions.left;
            facePositions.left = temp;
        }
        
        function rotateFacesRight() {
            // Right roll: reverse of left
            const temp = facePositions.front;
            facePositions.front = facePositions.left;
            facePositions.left = facePositions.back;
            facePositions.back = facePositions.right;
            facePositions.right = temp;
        }
        
        function applySingleMove(direction) {
            logMove(`Rolling ${direction}...`);
            
            // Apply the transform FIRST (with current face numbers showing)
            let newTransform = { x: 0, y: 0 };
            
            switch(direction) {
                case 'forward':
                    newTransform = { x: -90, y: 0 };
                    break;
                case 'backward':
                    newTransform = { x: 90, y: 0 };
                    break;
                case 'left':
                    newTransform = { x: 0, y: -90 };  // FIXED: was +90
                    break;
                case 'right':
                    newTransform = { x: 0, y: 90 };   // FIXED: was -90
                    break;
            }
            
            // Apply the transform immediately
            dice.style.transform = `rotateX(${newTransform.x}deg) rotateY(${newTransform.y}deg)`;
            currentTransform = newTransform;
            
            // Update transform display immediately
            document.getElementById('transformDisplay').textContent = 
                `Transform: rotateX(${currentTransform.x}°) rotateY(${currentTransform.y}°)`;
            
            // WAIT for animation to complete, THEN update face positions
            setTimeout(() => {
                // Now update face positions to match the new orientation
                switch(direction) {
                    case 'forward':
                        rotateFacesForward();
                        break;
                    case 'backward':
                        rotateFacesBackward();
                        break;
                    case 'left':
                        rotateFacesLeft();
                        break;
                    case 'right':
                        rotateFacesRight();
                        break;
                }
                
                // Update face display after the move completes
                updateFaceDisplay();
                logMove(`Result: Face ${facePositions.front} is now on front`);
                
            }, 500); // Wait for CSS animation to complete
        }
        
        function reset() {
            // Reset to initial state
            facePositions = {
                front: 1, back: 6, left: 5, right: 2, top: 3, bottom: 4
            };
            currentTransform = { x: 0, y: 0 };
            dice.style.transform = 'none';
            updateFaceDisplay();
            document.getElementById('moveLog').innerHTML = '';
            logMove('Reset to initial state');
        }
        
        function showTargetFace(targetFace) {
            logMove(`Attempting to show face ${targetFace}...`);
            
            // Find which position has the target face
            let targetPosition = null;
            for (const [position, face] of Object.entries(facePositions)) {
                if (face === targetFace) {
                    targetPosition = position;
                    break;
                }
            }
            
            if (!targetPosition) {
                logMove(`Error: Face ${targetFace} not found!`);
                return;
            }
            
            logMove(`Face ${targetFace} is currently on ${targetPosition}`);
            
            // Determine what move brings that position to front
            let moveNeeded = null;
            switch(targetPosition) {
                case 'front':
                    logMove(`Face ${targetFace} is already on front!`);
                    return;
                case 'back':
                    moveNeeded = ['left', 'left']; // Two moves to get back to front
                    break;
                case 'left':
                    moveNeeded = ['right'];
                    break;
                case 'right':
                    moveNeeded = ['left'];
                    break;
                case 'top':
                    moveNeeded = ['backward'];
                    break;
                case 'bottom':
                    moveNeeded = ['forward'];
                    break;
            }
            
            // Execute the move(s)
            if (moveNeeded) {
                executeSequence(moveNeeded, 0);
            }
        }
        
        function executeSequence(moves, index) {
            if (index >= moves.length) {
                logMove('Sequence complete!');
                return;
            }
            
            applySingleMove(moves[index]);
            setTimeout(() => {
                executeSequence(moves, index + 1);
            }, 600);
        }
        
        function findAndExecuteMove() {
            const targetFace = parseInt(document.getElementById('targetSelect').value);
            showTargetFace(targetFace);
        }
        
        function testRandomSequence() {
            const moves = ['forward', 'backward', 'left', 'right'];
            const sequence = [];
            for (let i = 0; i < 3; i++) {
                sequence.push(moves[Math.floor(Math.random() * moves.length)]);
            }
            
            logMove(`Random sequence: ${sequence.join(' → ')}`);
            executeSequence(sequence, 0);
        }
        
        function logMove(message) {
            const log = document.getElementById('moveLog');
            log.innerHTML += message + '<br>';
            log.scrollTop = log.scrollHeight;
        }
        
        // Initialize
        updateFaceDisplay();
        logMove('Face tracking dice initialized');
    </script>
</body>
</html>
